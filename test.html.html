<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scroll Scrub Video</title>

  <style>
    :root {
      --bg: #fafafa;
      --ink: #111;
      --hint-opacity: .6;
      --stage-h: 100vh;
      --loader-w: 240px;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: var(--bg);
      overflow-y: auto;           /* allow scrolling */
      overscroll-behavior: none;
      -ms-overflow-style: none;   /* IE/Edge hide scrollbar */
      scrollbar-width: none;      /* Firefox hide scrollbar */
    }
    html::-webkit-scrollbar, body::-webkit-scrollbar { display: none; }

    .stage {
      position: sticky;
      top: 0;
      height: var(--stage-h);
      width: 100%;
      background: var(--bg);
      display: grid;
      place-items: center;
      overflow: hidden;
      isolation: isolate;
    }

    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: var(--bg);
      opacity: 0;
      transform: scale(0.995);
      transition: opacity .6s ease-out, transform .8s ease-out;
    }
    video.ready { opacity: 1; transform: scale(1); }

    .hint {
      position: absolute; bottom: 24px; left: 50%; transform: translateX(-50%);
      font: 600 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--ink); opacity: var(--hint-opacity); user-select: none; pointer-events: none;
      text-align: center; padding: 0 12px;
    }

    /* Simple “indeterminate” loader bar shown until metadata arrives */
    .loader {
      position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
      width: var(--loader-w); height: 4px; border-radius: 999px; background: rgba(0,0,0,.1);
      overflow: hidden;
    }
    .loader i {
      display: block; height: 100%; width: 35%;
      background: linear-gradient(90deg, #007aff, #1ac6ff);
      animation: sweep 1.2s linear infinite;
    }
    @keyframes sweep {
      0%   { transform: translateX(-100%); }
      100% { transform: translateX(300%); }
    }

    .error {
      position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%);
      font: 600 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #c00; background: rgba(255,255,255,.9); border: 1px solid rgba(0,0,0,.08);
      padding: 8px 10px; border-radius: 10px; display: none;
    }

    /* Spacer defines total scroll distance (bigger = slower scrub) */
    .scroll-spacer { height: 5000px; }

    @media (max-width: 600px) {
      .hint { font-size: 13px; }
      .loader { width: 200px; }
    }
  </style>
</head>
<body>
  <div class="stage" aria-label="Scroll-scrub video section">
    <video id="heroVideo" preload="auto" muted playsinline></video>
    <div class="loader" id="loader" aria-hidden="true"><i></i></div>
    <div class="hint">Scroll or swipe to explore</div>
    <div class="error" id="errBox"></div>
  </div>

  <div class="scroll-spacer" id="scrollSpacer" aria-hidden="true"></div>

  <script>
    (function () {
      // Explicit root path avoids relative-path surprises on nested routes
      const VIDEO_URL = "/Cadac.mp4";

      const video    = document.getElementById("heroVideo");
      const loader   = document.getElementById("loader");
      const errBox   = document.getElementById("errBox");
      const spacer   = document.getElementById("scrollSpacer");

      let rafId = null;
      let loopOn = false;

      // Helpful: ensure vertical pan is allowed on touch
      document.body.style.touchAction = "pan-y";

      function showError(msg) {
        errBox.textContent = msg;
        errBox.style.display = "block";
        loader.style.display = "none";
      }

      // Start the scrub loop only once metadata (duration) is known
      function startScrubLoop() {
        if (loopOn) return;
        loopOn = true;
        loader.style.display = "none";
        video.classList.add("ready");

        const getProgress = () => {
          const maxScroll = Math.max(1, spacer.offsetHeight - window.innerHeight);
          const y = window.scrollY || window.pageYOffset || 0;
          return Math.min(1, Math.max(0, y / maxScroll));
        };

        const tick = () => {
          const progress = getProgress();
          const dur = Number.isFinite(video.duration) ? video.duration : 0;
          const safeEnd = Math.max(0, dur - 0.05);
          const target = progress * safeEnd;

          // smooth ease toward target
          const current = video.currentTime || 0;
          video.currentTime = current + (target - current) * 0.15;

          rafId = requestAnimationFrame(tick);
        };
        rafId = requestAnimationFrame(tick);
      }

      function stopScrubLoop() {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
        loopOn = false;
      }

      // Load video via native pipeline (handles range requests & caching)
      function loadVideo() {
        // Use <source> for wider UA compatibility
        const s = document.createElement("source");
        s.src = VIDEO_URL;
        s.type = "video/mp4";
        video.appendChild(s);

        // Kick the pipeline
        try { video.load(); } catch (_) {}

        // Some browsers emit loadedmetadata, others loadeddata first
        const ready = () => {
          video.removeEventListener("loadedmetadata", ready);
          video.removeEventListener("loadeddata", ready);

          if (!Number.isFinite(video.duration) || video.duration <= 0) {
            // If duration is still unknown, wait for canplay as a last resort
            video.addEventListener("canplay", startScrubLoop, { once: true });
            return;
          }
          startScrubLoop();
        };

        if (video.readyState >= 1) {
          // HAVE_METADATA or greater
          ready();
        } else {
          video.addEventListener("loadedmetadata", ready, { once: true });
          video.addEventListener("loadeddata", ready, { once: true });
        }
      }

      // Basic existence check to give a clear error if file is missing
      async function headCheck(url) {
        try {
          const res = await fetch(url, { method: "HEAD" });
          return res.ok;
        } catch {
          return false;
        }
      }

      (async () => {
        const ok = await headCheck(VIDEO_URL);
        if (!ok) {
          showError("Could not load the video at " + VIDEO_URL + " (check file path/casing in your deployment).");
          return;
        }
        loadVideo();
      })();

      // Lifecycle hygiene
      window.addEventListener("visibilitychange", () => {
        if (document.hidden) stopScrubLoop();
        else if (Number.isFinite(video.duration) && video.duration > 0) startScrubLoop();
      });
      window.addEventListener("pagehide", stopScrubLoop);

      // Optional: quick keyboard test (arrow keys scrub by nudging scroll)
      window.addEventListener("keydown", (e) => {
        const step = 60; // px
        if (e.key === "ArrowDown") window.scrollBy(0, step);
        if (e.key === "ArrowUp")   window.scrollBy(0, -step);
      });
    })();
  </script>
</body>
</html>
